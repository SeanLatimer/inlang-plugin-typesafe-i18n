var g=async(e,t,r=0)=>{let n=await e.readdir(t,{withFileTypes:!0}),o=n.filter(a=>!a.isDirectory()).map(({name:a})=>({name:a.toString(),folder:""})),i=n.filter(a=>a.isDirectory());if(r)for(let a of i)o.push(...(await g(e,`${t}/${a.name}/`,r-1)).map(s=>({name:s.name.toString(),folder:a.name.toString()})));return o},m=async(e,t,r)=>{let n=r==="JavaScript"?".js":".ts";return(await g(e,t,1)).filter(({folder:i,name:a})=>i&&a===`index${n}`).map(({folder:i})=>i)},d=async e=>({baseLocale:"en",tempPath:"./node_modules/typesafe-i18n/temp-output/",outputPath:"./src/i18n/",outputFormat:"TypeScript",typesFileName:"i18n-types",utilFileName:"i18n-util",formattersTemplateFileName:"formatters",typesTemplateFileName:"custom-types",esmImports:!1,adapter:void 0,generateOnlyTypes:!1,banner:"/* eslint-disable */",runAfterGenerator:void 0,...e}),y=async e=>{let t=await e.readFile(".typesafe-i18n.json").catch(()=>"{}");return JSON.parse(t.toString())},l=async e=>{let t=await y(e);return d(t)},f=async e=>{let t=await l(e);return{base:t.baseLocale,locales:await m(e,t.outputPath,t.outputFormat)}};function c(e){return t=>r=>e({settings:t,env:r})}var h=c(({env:e})=>({id:"ivanhofer.inlang-plugin-typesafe-i18n",async config(){let{base:t,locales:r}=await f(e.$fs);return{referenceLanguage:t,languages:r,readResources:({config:n})=>w({config:n,...e}),writeResources:({config:n,resources:o})=>P({config:n,resources:o,...e})}}})),p=(...e)=>e.map(t=>{for(;t.startsWith("/");)t=t.substring(1);for(;t.endsWith("/");)t=t.substring(0,t.length-1);return t}).join("/");async function w({config:e,$fs:t}){let r=await l(t),n=[];for(let o of e.languages){let i=await b(t,r.outputPath,o);n.push(R(i,o))}return n}var b=async(e,t,r)=>{let a=(await e.readFile(p(t,`${r}/index.ts`),{encoding:"utf-8"})).toString().split(`
`).filter(u=>!u.trim().startsWith("import ")).join(`
`).replace(/:.*=/g," =").replace(/ satisfies.*\/n/g,`
`);return(await import("data:application/javascript,"+encodeURIComponent(a))).default},R=(e,t)=>({type:"Resource",languageTag:{type:"LanguageTag",name:t},body:Object.entries(e).map(([r,n])=>x(r,n))}),x=(e,t)=>({type:"Message",id:{type:"Identifier",name:e},pattern:{type:"Pattern",elements:[{type:"Text",value:t}]}});async function P({$fs:e,config:t,resources:r}){let n=await l(e);for(let o of r){let i=o.languageTag.name,a=v(o),s=i===t.referenceLanguage?"BaseTranslation":"Translation",u=`import type { ${s} } from '${p(n.outputPath,n.typesFileName)}'
const ${i}: ${s} = ${a}

export default ${i}`;await e.writeFile(p(n.outputPath,`${i}/index.ts`),u)}}var v=e=>{let t=Object.fromEntries(e.body.map(T));return JSON.stringify(t,null,3)};function T(e){return[e.id.name,I(e.pattern)]}function I(e){return e.elements.map(C).join("")}function C(e){switch(e.type){case"Text":return e.value;case"Placeholder":return`{${e.body.name}}`}}export{h as default};
/*! Bundled license information:

@inlang/core/dist/plugin/pluginBuildConfig.js:
  (*! DON'T TOP-LEVEL IMPORT ESBUILD PLUGINS. USE DYNAMIC IMPORTS. *)
  (*! See https://github.com/inlang/inlang/issues/486 *)
*/
